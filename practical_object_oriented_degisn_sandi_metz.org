** Chapter 1 Object-Oriented Design
***** The world is procedural, also object-oriented.
***** paradigm/perspective shifting from 'a collection of predefined procedures' to 'a series of messages passing between objects'
***** This chapter
****** a general discussion of OOD
****** the case of design, when to do it, how to judge it
****** an overview of OOP with term definition
*** 1.1 In Praise of Design
**** 1.1.1 The problem Design Solves
***** with a complete and correct set of requirements, once the code written, never change
****** spinning plates in a world without friction or gravity
***** Changing requirements are the programming equivalent of friction and gravity, which is unavoidable.
****** It makes design matter.
**** 1.1.2 Why Change Is Hard
***** OOP: interacting objects to produce the behavior of the whole
***** messaging properly to the correct tharget object -> the sender know things about the reveiver
****** This knowledge creates dependencies between the two, standing in the way of change.
***** OOP is about managing dependencies.
****** arrange dependencies for objects to tolerate changes
****** objects knowing too much about one another
******* An insignificant change on one object cause no code untouched, reculsively forcing changes upon its collaborators.
******* resist being reused in different contexts, painful to test, susceptible to being duplicated
**** 1.1.3 A Practical Definition of Design
***** Every application is a collection of code; *the code's arrangement is the design*.
***** You must not only write code for the feature addressing current issue, you must also create code *amenable to being changed later*.
***** application requirements / costs and benefits of design alternatives
***** Taking the future into consideration is *not anticipation of unknown future requirements*
****** leaving room to move, to allow you to de design later, to reduce the cost of change

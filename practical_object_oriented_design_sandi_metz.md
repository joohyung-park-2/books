Chapter 1 Object-Oriented Design
- The world is procedural, also object-oriented.
- paradigm/perspective shifting from 'a collection of predefined procedures' to 'a series of messages passing between objects'
- This chapter
  - a general discussion of OOD(1.1)
  - the case of design(1.2), when to do it, how to judge it(1.3)
  - an overview of OOP with term definition(1.4)
- 1.1 In Praise of Design
  - 1.1.1 The problem Design Solves
    - with a complete and correct set of requirements, once the code written, never change
      - spinning plates in a world without friction or gravity
    - Changing requirements are the programming equivalent of friction and gravity, which is unavoidable.
      - It makes design matter.
  - 1.1.2 Why Change Is Hard
    - OOP: interacting objects to produce the behavior of the whole
    - messaging properly to the correct tharget object -> the sender know things about the reveiver
      - This knowledge creates dependencies between the two, standing in the way of change.
    - OOP is about managing dependencies.
      - arrange dependencies for objects to tolerate changes
      - objects knowing too much about one another
        - An insignificant change on one object cause no code untouched, reculsively forcing changes upon its collaborators.
        - resist being reused in different contexts, painful to test, susceptible to being duplicated
  - 1.1.3 A Practical Definition of Design
    - Every application is a collection of code; **the code's arrangement is the design**.
    - You must not only write code for the feature addressing current issue, you must also create code **amenable to being changed later**.
    - application requirements / costs and benefits of design alternatives
    - Taking the future into consideration is **not anticipation of unknown future requirements**
      - leaving room to move, to allow you to de design later, to reduce the cost of change
- 1.2 The Tools of Design
  - not about following a fixed set of rules
  - wandering a maze of requirements where every juncture represents a decision point
  - Design principles and patterns are the chisels and files of an OO designer
  - 1.2.1 Design Principles
    - **[SOLID](https://en.wikipedia.org/wiki/SOLID): top five most well-known principles**
    - **[DRY(Don't Repeat Yourself)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself), [LoD(the Law of Demeter)](https://en.wikipedia.org/wiki/Law_of_Demeter)**
      - These were started as an opinion how to write good code
      - Measuring the quality of code change OOP from 'disputed opinion' into 'measurable science'.
        - overall size of classes
        - entaglements that classes have with one another
        - depth/breadth of inheritance hierarchies
        - the number of  methods getting invoked as a result of any message sent
      - The research shows a definite correlation between use of these techniques and high-quality code.
        - Chidamber, Kemerer, Basili, 1990
        - Laing, Coleman, 2001
      - Follow the principles!
  - 1.2.2 Design Patterns
    - **GoF: simple and elegant solutions to specific problems**
    - It gave all programmers the means to communicate and collaborate.
    - Pattern abusement
      - Pattern misapplication results in complicated and confusing code
      - This book is **not about patterns.**
      - It will **prepare you to understand them, give you the knowledge to choose/use them properly.**
- 1.3 The Act of Design
  - Does it get easy designing OO software with design principles/patterns? 
    - **Nop**, the invention of tools doesn't guarantee good sculptures. It depends on the programmer's experience
  - 1.3.1 How Design Fails
    - *Yes, I can add the feature, but it will break everything.*
      - Successful but undesigned app carry the seeds of their own destruction, vulnerability to change.
    - *No, I can't add that feature; it wasn't designed to do that.*
      - **A little bit of knowledge is dangerous**
      - A programmer have heard of OOD without understanding how to apply it hem itself in complicated, beautifuls castles of code
    - *Well, I can certainly write this, but it's not what you really want and you will eventually be sorry.*
      - when the act of design is separated from the act of programming
      - **Design: a process of progressive discovery that relies on a feedback loop(the iterative techniques of the Agile development for OOD)**
        - to adjust regularly, to evolve naturally
        - isolated design: no adjustments, early failures of understanding cemented into the code
  - 1.3.2 When to Design
    - Customers cannot define the sofware they want before seeing it
    - Agile said, the most cost-effective way to produce what customers really want is
      - building software on small bit at a time, alter ideas about the next
    - No way to predict when the app will be done
    - No [BUFD](https://en.wikipedia.org/wiki/Big_Design_Up_Front)(Bring Up Front Design, about to the third case of 1.3.1)
      - Desire for BUFD providing a feeling of control that would otherwise be lacking, a temporal illusion
      - leading to an **adversarial relationship** between customers and programmers
      - Any big design created in advance never (be correct/meet the customer's needs).
      - Request of changes happens when the customer attempt to use it.
    - Missing the delivery deadline even due to the spec changes: programmer's fault
    - Missing the spec not fulfilling the actual need: customer's fault
      - BUFD scrambling defense **against being the person who ends up holding the hot potato of blame**
    - Agile
      - accepts the handicap: **unavoidable uncertainty** in advance of the app's existence
      - provides strategies to overcome the handicap while **knowing neither the target nor the timeline**
    - Design of BUFD
      - completely specifying / totally documenting the every feature inside
      - design matters how to arrange all of the code
    - Design of Agile
      - without well-designed code, you should rewrite your app during every iteration.
      - design matters for code to be flexible enough against changes
  - 1.3.3 Judging Design
    - SLOC: to measure programmers' effort and app complexity
      - limitation: altering the reward structure in ways that harm quality
    - OOD metric: how well code follows OOD principles
      - seemingly well-designed app racking up impressive numbers of OOD violcations
      - more poorly scored code, harder to change
      - limitation: beautiful OOD with good score, but over-anticipating the future
        - do the wrong thing in the right way
    - the ultimate metric? (cost/feature) / time interval
      - difficulty to define, track, and measure each paramaters
    - **the time interval**
      - **you must do the best you can in the time you have.**
      - **borrowing time from the future is taking on technical debt.**
      - design decision depends on your skils and your timeframe.
        - no value on design preventing on-time delivery
        - delivering half of a well-desinged app == delivering no app at all
    - The break-even point for design
      - **inexperienced programmers doing a lot of anticipatory design**
        - **never reach a point where their earlier design efforts pay off**
    - **The remainder of this book teaches skills you can use to shift the break-even point in your favor.**
- 1.4 A Brief Introduction to OOP
  - Importance: Messages > Object
  - 1.4.1 Procedural Languages
    - Any function do anything to data followed by unpredictable influnces
  - 1.4.2 OO Languages
    - object
      - behavior + data to which they alone control access(encapsultation)
      - deciding how mich of its data to expose
      - an instance of an class
    - message
      - invoke objects' behavior
    - class
      - abstraction of identical behavior(methods) / of variables(attributes)
    - **Knowing an object's type lets you have expectations about the messages to which it responds.**

Chapter 2 Designing Classes with a Signle Reponsibility
- **The foundation of an OO system is the message, the core of design.**
- The quality of easy changeability reveals the craft of programming.
- Much research ha gone into indentifying the qualities.
- 2.1 Deciding What Belongs in a Class
  - The problem is not one of technical knowledge but of organization
    - you know how to write the code but not where to put it.
  - 2.1.1 Grouping Methods into Classes
    - decisions you make today will need to be changed later.
    - Design is more the art of preserving changeability than it is the act of achieving perfection.
  - 2.1.2 Organizing Code to Allow for Easy Changes
    - **T**ransparent
      - **no side effects** unexpected
      - The consequences of change should be **obvious** in the code that is changing and in distant code that relies upon it.
    - **R**easonable
      - small requirement changes, small code changes
      - The cost of any change should be **proportional** to the benefits the change achieves(meeting requirement changes).
    - **U**sable
      - reusable existing code
      - Existing code should be **usable in new and unexpected contexts**.
    - **E**xemplary
      - existing code should be an good example for new code
      - The code itself should encourage those who change it to perpetuate these qualites.([example](https://hashrocket.com/blog/posts/in-conversation-sandi-metz))
    - The first step in creating code that is TRUE is to ensure that each class has a single, well-defined reponsibility.
- 2.2 Creating Classes That Have a Single Responsibility
  - 2.2.1 [An Example Application:Bicycles and Gears](https://oss.navercorp.com/joohyung-park/practical-object-oriented-design/commit/b0402d512e054d2e2f7ed1443e78ae345fe33b88)
  - 2.2.2 Why Single Responsibility Matters
    - If the various reponsibilities are likely thoroughly entangled within the class,
      - Impossible to use just the behavior you need -> code duplication(AKA ctrl-c/v) -> additional maintenance -> bug oriented design
      - Change for a reason unrelated to your use -> breaking more classes depedning on it -> inclease app's chance of breaking unexpectedly
  - 2.2.3 Determining If a Class Has a Single Responsibility
    - Describe what a class is actually doing in one sentence without 'or/and'!!
    - Highly cohesive: to have a single responsibility
    - Responsibility-Driven Design(RDD) by Brian Wilkerson
      - not about a class do only one very narrow thing, but do things highly related to its purpose
  - 2.2.4 Determining When to Make Design Decisions
    - *improve it now*
      - You are wasting a lot of time between design alternatives before rolling the dice and choosing the wrong one.
      - The ugly Gear class is both *transparent* and *reasonable*, if there's **no dependency**.
      - The new dependencies will supply the exact information you need to make good design decisions.
      - **Make the secision only when you must with the information you have at that time.**
    - *improve it later*
      - Someone will reuse Gear or create new code that follows its pattern while you are waiting for better information.
        - They believe the Gear code is intended to be as it is.
    - No design perfection, every choice has a price.
    - Try **to minimize costs** by making tradeoff
- 2.3 Writing Code That Embraces Change
  - 2.3.1 [Depend on Behavior, Not Data](https://oss.navercorp.com/joohyung-park/practical-object-oriented-design/commit/0ee28a946a805921318177c44444e57c2f60f5bc)

Chapter 3 Managing Dependencies
- A single object cannot know everything, so inevitably it will have to talk to another object
- For any desired behavior
  - an object knows it personally(ch 2)
  - an object inherits it(ch 6)
  - an object knows another object who knows it(ch 3)
- Knowing(dependency) must be managed carefully
- 3.1 Understanding Dependencies
  - 3.1.1 Recognizing Dependencies
    - Four dependecies on this line, "Wheel.new(rim, tire).diameter"
      - expecting a class named Wheel
      - expecting a Wheel instance to respond to diameter
      - expecting a Wheel.new requires a rim and a tire
      - expecting a Wheel takes a rim as the first argument, and a tire as the second one
    - most of the dependencies listed above are unnecessary
    - manage dependencies so that each class has the fewest possible
  - 3.1.2 Coupling Between Objects(CBO)
    - When two or more objects are so tightly coupled that theey behave as a unit
	  - impossible to reuse just one
	  - changes to one object force changes to all
  - 3.1.3 Other Dependencies
    - Law of Demeter violation(ch 4)
	  - an object knowing another knowing another knowing something: message chaining
	  - a dependency betrween the original object and every object and meesage along the way to the target
	  - the 1st might be forced to change because of any changes on intergmediate objects
	- Tests too tightly coupled to code(ch 9)
	  - Tests come first driving design
	  - broken by code refactoring
